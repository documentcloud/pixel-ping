// Generated by CoffeeScript 1.7.1
var VERSION, config, configPath, emptyHeaders, endParams, endReqOpts, flush, fs, http, log, merge, pixel, pixelHeaders, querystring, record, reset, serialize, server, store, url;

fs = require('fs');

url = require('url');

http = require('http');

querystring = require('querystring');

VERSION = '0.1.3';

store = {};

record = function(params) {
  var key, _ref;
  if (!(key = (_ref = params.query) != null ? _ref.key : void 0)) {
    return;
  }
  store[key] || (store[key] = 0);
  return store[key] += 1;
};

serialize = function() {
  var data;
  data = {
    json: JSON.stringify(store)
  };
  if (config.secret) {
    data.secret = config.secret;
  }
  return querystring.stringify(data);
};

reset = function() {
  var old_store;
  old_store = store;
  store = {};
  return old_store;
};

merge = function(new_store) {
  var hits, key, _results;
  _results = [];
  for (key in new_store) {
    hits = new_store[key];
    store[key] || (store[key] = 0);
    _results.push(store[key] += hits);
  }
  return _results;
};

flush = function() {
  var data, old_store, on_error, request;
  log(store);
  if (!config.endpoint) {
    return;
  }
  on_error = function(message) {
    if (!config.discard) {
      merge(old_store);
    }
    return console.log(message);
  };
  data = serialize();
  old_store = reset();
  endReqOpts['headers']['Content-Length'] = data.length;
  request = http.request(endReqOpts, function(res) {
    if (res.statusCode <= 299 && res.statusCode >= 200) {
      return console.info('--- flushed ---');
    } else {
      return on_error("--- flush failed with code:" + res.statusCode);
    }
  });
  request.on('error', function(e) {
    return on_error("--- cannot connect to endpoint : " + e.message);
  });
  request.write(data);
  return request.end();
};

log = function(hash) {
  var hits, key, _results;
  _results = [];
  for (key in hash) {
    hits = hash[key];
    _results.push(console.info("" + hits + ":\t" + key));
  }
  return _results;
};

server = http.createServer(function(req, res) {
  var params;
  params = url.parse(req.url, true);
  if (params.pathname === '/pixel.gif') {
    res.writeHead(200, pixelHeaders);
    res.end(pixel);
    record(params);
  } else {
    res.writeHead(404, emptyHeaders);
    res.end('');
  }
  return null;
});

configPath = process.argv[2];

if (configPath === '-v' || configPath === '-version' || configPath === '--version') {
  console.log("Pixel Ping version " + VERSION);
  process.exit(0);
}

if (!configPath || (configPath === '-h' || configPath === '-help' || configPath === '--help')) {
  console.error("Usage: pixel-ping path/to/config.json");
  process.exit(0);
}

config = JSON.parse(fs.readFileSync(configPath).toString());

pixel = fs.readFileSync(__dirname + '/pixel.gif');

pixelHeaders = {
  'Cache-Control': 'private, no-cache, proxy-revalidate, max-age=0',
  'Content-Type': 'image/gif',
  'Content-Disposition': 'inline',
  'Content-Length': pixel.length
};

emptyHeaders = {
  'Content-Type': 'text/html',
  'Content-Length': '0'
};

if (config.endpoint) {
  console.info("Flushing hits to " + config.endpoint);
  endParams = url.parse(config.endpoint);
  endReqOpts = {
    host: endParams.hostname,
    port: endParams.port || 80,
    method: 'POST',
    path: endParams.pathname,
    headers: {
      'host': endParams.host,
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  };
} else {
  console.warn("No endpoint set. Hits won't be flushed, add \"endpoint\" to " + configPath + ".");
}

process.on('SIGUSR2', function() {
  console.log('Got SIGUSR2. Forcing a flush:');
  return flush();
});

process.on('uncaughtException', function(err) {
  return console.error("Uncaught Exception: " + err);
});

server.listen(config.port, config.host);

setInterval(flush, config.interval * 1000);
